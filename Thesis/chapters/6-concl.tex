The paper set out to describe the intricacies of software transaction memory and its main approaches, namely the non-blocking and lock-based versions. In doing so, concurrent datastructure design emerged as a potential area where the transactional techniques could be applied successfully. By using the transactional approach to create concurrent datastructures, the process of crafting them moves away from the use of error-prone and difficult-to-reason-about lock-based and unnaturally structured lock-free algorithms to much more accessible and straightforward ones. Similarly to findings described in \cite{is-tx-easier}, this paper could also empirically conclude that apart from a few quirks in notation, writing concurrent transactional algorithms are not very different from their sequential counterpart while also being concurrent and correct. Results showed that the commit-time lock-based transactions could only be applied, without imposing an unnatural design on the datastructure itself, in cases where there are no direct dependencies between the writes. This is attributed to the fact that the commit-time transaction records its writes as a list of (address, value) 2-tuples that are oblivious to whether one write depends on the result of others. The encounter-order approach, however, can safely be applied in all situations; moreover, as opposed to findings of papers like \cite{tl, tl2}, under high-contention, it even outperforms its commit-time counterpart. This is due to the fact that under high contention, the commit-time transaction has a much higher abort rate as its read-set is invalidated more and more frequently, and its operations have worse time complexities, which hinders its performance. Further research could investigate how word-based commit-time transactions can overcome their limitations concerning the dependencies between their writes. Moreover, many popular datastructures whose internal complexities create rather complex lock-based or lock-free implementations could be explored and show that its transactional version is rather straightforward. Shifting to transactional design in place of the lock-based or lock-free style could be considered a viable alternative by creating an accessible abstraction to deal with concurrency.