This section gives an overview of the history of \textit{Transactional Memory}, starting from Herlihy and Moss' 1993 paper, in which the term was coined\cite{herlihy-moss}. Following it, \textit{Software Transactional Memory} is presented through multiple proposed versions like the original non-blocking implementation of Shavit and Touitou\cite{shavit-stm}, Herlihy's DSTM\cite{DSTM} and Fraser's OSTM\cite{OSTM, ostm2}. Finally, the proposed \textit{blocking} implementations are detailed with attention to Ennals' STM\cite{ennals-stm}, but also the \textit{Transactional Locking I \& II} algorithms proposed by Shavit et al.\cite{tl, tl2}.

\section{Hardware Transactional Memory}

\textit{Transactional Memory} was introduced to the distributed computing world by Herlihy and Moss in 1993\cite{herlihy-moss}. In their paper, the authors detailed a new multi-processor architecture providing lock-free synchronization, which would enable programmers to specify read-modify-write operations on several words in memory, via transactions. It is implemented as an extension to already existing cache-coherence protocols, and require specialised hardware support in terms of instructions such as \texttt{LT} "Load-transactional", \texttt{ST} "Store-transactional", etc\cite{herlihy-moss}. Their proof of concept describes transactions as a \textit{serializable} and \textit{atomic} finite sequence of instructions. Serializability refers to the fact that transactions appear to happen one after another and they never appear to interleave. Atomicity indicates that transactions make tentative changes to shared memory and either \textit{commit}, by making its changes atomically visible to other transactions or \textit{abort}, by discarding its changes\cite{herlihy-moss}.\par

\section[Non-blocking Software Transactional Memory]{Non-blocking Software Transactional\\Memory}
\subsection{STM of Shavit et al.}
In 1996, Shavit and Touitou proposed an alternative transactional memory design which is implemented entirely in software, called \textit{Software Transactional Memory}\cite{shavit-stm} (or \textit{STM} for short). Their design builds on top of that of Herlihy and Moss, however, it can also be implemented on existing machines with \textit{Load-link/Store-conditional} operations\cite{shavit-stm}. The paper focuses on implementing \textit{static transactions}, where the data set is known in advance, and therefore, each transaction can be viewed as an atomic procedure storing the given new values\cite{shavit-stm}. Their STM implementation is also \textit{non-blocking}, which means that a thread is guaranteed to make progress even when other threads are suspended.

Implementation wise, the original STM approach was as follow. Two shared datastructures coordinate the processes and their transactions: a vector \texttt{Memory} of size M which contains every transactional memory block, and a vector \texttt{Ownership} of the same size pointing to \textit{records} that determine which transaction owns a certain block of memory. Records are shared structures that store information about the current transaction its corresponding process started. 

When executing a transaction, a process's record is initialised and status set to \textit{stable}. Afterwards, ownership for all involved locations of the dataset needs to be acquired in some increasing order. If that succeeds, the transaction writes the old values to the locations' records, calculates the new values and writes them to the memory locations, and finally, sets its status to \textit{success}. If the ownerships cannot all be acquired, the transaction sets its status to \textit{failure, failadd} where \textit{failadd} is the address for which the ownership couldn't be acquired\cite{shavit-stm}. In case of a failed transaction, the algorithm utilises a \textit{cooperative method} to help the other transaction holding ownership of the location needed for the failed transaction. This is done as follows: if the failed transaction is not already a \textit{helping transaction}, it first releases all ownerships that it previously acquired and helps the transaction that holds ownership to the location which failed by becoming a helper for that transaction\cite{shavit-stm}.

\subsection{Herlihy's DSTM}
Whereas the original STM algorithm of Shavit and Touitou was \textit{static}, where the transactions and memory usage is known in advance\cite{shavit-stm}, the first \textit{dynamic} Software Transactional Memory implementation was proposed by Herlihy et al. in 2003, known as \textit{DSTM}\cite{DSTM}. The algorithm allows dynamic creation of transactions and transactional objects, moreover, transactions can determine their course of action based on previously read (transactional) values, which makes it suitable to operate on dynamic datastructures\cite{DSTM}. It inherits the \textit{non-blocking} and \textit{lock-free} properties, i.e. a suspended thread will not prevent others from advancing. 

The algorithm described in the paper is originally implemented in \texttt{Java} and its workings can be described as follows. The \textit{DSTM} algorithm operates on \textit{transactional objects} which are accessed by transactions. These transactional objects are a wrapper around conventional objects, which can be modified by first \textit{opening} the transactional objects and modifying its contents\cite{DSTM}. These changes are only \textit{speculative}, i.e. they have no observable effect until the transaction commits. The interface the authors provided consist of the following: firstly, the \texttt{TMThread} class represents transactional threads, which is implemented as a wrapper around \texttt{Java}'s thread class. The thread class holds a status field which can either be \texttt{ACTIVE}, \texttt{COMMITTED} or \texttt{ABORTED}. Secondly, the \texttt{TMObject} class represents transactional objects accessed by the threads, which can be opened in \texttt{READ} or \texttt{WRITE} modes. Each transactional type must have the \texttt{TMCloneable} interface implemented which provides a \texttt{clone()} method used for speculative modification\cite{DSTM}. 

After a transaction begins, it must call \texttt{open()} with an appropriate mode on the transactional objects it wishes the change. This creates a working copy of the object (using the before-mentioned \texttt{clone()} method) which the transaction can safely modify, called the \textit{version} of the object. Each thread maintains a read-table of opened objects. The version of an object is determined by the status of the transaction that last opened it in \texttt{WRITE} mode. The \texttt{TMObject} class holds a reference to a \texttt{Locator} object, which in turn holds two versions of each object and a reference to the transaction that last opened it in \texttt{WRITE} mode. If that transaction commits, the \textit{new} version of the object becomes valid, else the \textit{old} version. The level of indirection by introducing the \texttt{Locator} object in between an object's metadata and its contents is necessary to be able to atomically change the three field of the \texttt{Locator}, and therefore, the \texttt{TMObject} itself. This is performed by swinging the reference in the \texttt{TMObject} class to a new \texttt{Locator}\cite{DSTM}. After each open call, the transaction is \textit{validated}, to ensure that the accessed object's \textit{version} is not outdated yet, i.e. another transaction hasn't committed and modified the object in the meanwhile. This is performed by checking each entry in the read-only table and confirming that the local version of an object is still the latest committed version of the object and that the transaction is still active and has not been aborted\cite{DSTM}. Committing a transaction involves validating its read-table and using a \textit{CAS} operation to change its status from \texttt{ACTIVE} to \texttt{COMMITTED}\cite{DSTM}.

\subsection{Fraser's OSTM}
The STM implementation proposed by Fraser in \cite{OSTM} and summarised by Fraser and Harris in \cite{ostm2} titled \textit{OSTM} for \textit{object-based} STM, shares some of the key elements of Herlihy et al.'s \textit{DSTM}\cite{DSTM}. 

The algorithm is both \textit{obstruction-free} and operates on \textit{objects} as the unit of concurrency, which contain \textit{references} that can be opened for transactional access\cite{OSTM}. Each transaction maintains \textit{read-only} and \textit{read-write} linked-lists of \textit{object handles} which point to \textit{object-headers}. These headers are used to point to the most recent version of an object that is accessed by a transaction. When an object of opened from write access, a \textit{shadow copy} of the object is created. The shadow copy is used to make tentative changes to an object, which will become visible to the application upon successful commit\cite{OSTM}.

Transactional commits contain two phases: the \textit{acquire} and \textit{release} phases. In the acquire phase, each opened object's header must be acquired in some efficient order, by replacing the object handles with the transactions \textit{descriptor}. If a header is already acquired by another transaction, that transaction is aided to finish\cite{OSTM}. After the acquire phases, based on its outcome, the transaction's status is changed atomically to either successful or aborted. On success, in the \textit{release} phase, each object has its header swinged to its shadow copy by a \textit{Compare-and-Swap} operation\cite{OSTM}.

Three issues are mentioned by the authors with the current design. Firstly, in order to avoid a performance bottleneck when opening objects for read access on datastructures where there is a single entry point, the algorithm only acquires headers for objects in the read-write list which is followed by a \textit{read} phase. In the read phase, the algorithm checks whether the version of an object in its read-only list matches that of the object when it was first opened. In case they do, the algorithm can commit, else it must abort\cite{OSTM}.

Secondly, in some cases, an object may be updated after the read phase, but before the transaction status is updated and its changes are visible. To avoid this, transactions report a new status \textit{read-checking} in their read phase and ensuring that the transaction is such a phase atomically commit or abort. This is done by helping a transaction in its read phase reach its \textit{decision point}, i.e. when its accessed objects modifications become visible to others, or the transaction aborts\cite{OSTM}.

Thirdly, in the case when a cycle of transmissions wishing to read an object owned by the next transaction, to avoid deadlock, the transactions can abort others. To avoid livelock, not every transaction should be aborted, therefore, only the transaction with the lowest descriptor address can make progress. This ensures that the cycles are broken and the implementation remains \textit{obstruction-free}\cite{OSTM}.

\section{Blocking Software Transactional Memory}
\subsection{Ennals' STM}
While non-blocking STM implementations were gaining momentum, in 2006, Robert Ennals suggested that the non-blocking property is actually detrimental to performance. He showed that by not guaranteeing the transactions to be obstruction-free, the performance of STMs can be increased significantly\cite{ennals-stm}. The arguments for this proposal stems from the fact that while the non-blocking property is essential in distributed computing, it is not much so in non-distributed STM\cite{ennals-stm}. Ennals argues that porting multi-threaded programs to STM will be done by converting atomic blocks to transactions. In this case, a transaction blocking a lower or same priority one is acceptable since the same behaviour would be observed in the non-parallelised version of the program\cite{ennals-stm}.\par 

The paper then argues for the unnecessity of obstruction-freedom, which boils down to three claims. The first claim is that long-running transactions cannot block other transactions. This is refuted by the fact that obstruction-freedom only guarantees progress for nonconflicting transactions, and therefore, long-running transactions either have to be able to block conflicting transactions or have to be preempted\cite{ennals-stm}. The second argument for obstruction-freedom tells that the OS might halt if a task is switched out that holds critical resources. The authors identify that these context-switches are rare and not of great importance since a proper runtime system should identify and adapt the number of tasks to the number of cores available. Therefore, temporary switches that cause the system to block are acceptable and have an overall slight effect\cite{ennals-stm}. The third and last claim proposed by those in favour of obstruction-freedom gives that the OS might halt if a thread fails. This is rebutted by the fact that, either in the case of a software failure or in the case of a hardware failure, non-blocking STM would fail as well\cite{ennals-stm}.\par 

The authors point out two optimizations that cannot be applied when obstruction-freedom is a goal:

\begin{enumerate}
    \item Storing object metadata inline, making extra cache misses unlikely
    \item Bounding the number of active cores by the number of active transactions, to avoid unnecessary conflicts
\end{enumerate}

The first optimization is necessary since previously described non-blocking STM implementations\cite{OSTM, DSTM} require multiple lookups to find the current version of the object from the metadata, which leads to a performance loss. Obstruction-freedom does not permit inline metadata, since two transactions $\mathcal{A}$ and $\mathcal{B}$ working on the same object can only safely execute when $\mathcal{A}$ blocks $\mathcal{B}$ until it has finished writing the object\cite{ennals-stm}. The rationale behind the second optimization is that a non-blocking STM implementation does not wait to start a new transaction when all cores of a machine already execute a transaction. This creates a bottleneck, as the number of concurrent transactions is directly proportional to the number of conflicts among them, which then decreases overall performance\cite{ennals-stm}.\par

Implementation-wise, Ennals' STM includes two main points. Firstly, it uses \textit{encounter-order locking} on objects that a transaction wishes to write. This entails holding onto locks until the transaction either commits or aborts\cite{ennals-stm}. Secondly, the authors utilise optimistic control over reads, which involves not locking objects when reading them, but recording the object's current \textit{version number}. If that number remains the same throughout the execution of the transaction, or it only changes by the actions of the transaction itself, the transaction can safely commit, else it must abort.

\subsection{TL}
The claims of Ennals were endorsed by Dice and Shavit in a follow-up paper, in which they detail a new STM algorithm titled \textit{Transactional Locking}\cite{tl}, that outperforms the proposed blocking algorithm of Ennals\cite{ennals-stm}. In their paper, the authors argue that lock-based STM implementations outperformed their non-blocking counterparts on a variety of use-cases\cite{tl}. They point out that while the STM of Ennals\cite{ennals-stm} uses \textit{encounter-order locking}, this mechanism only performs well on uncontended datastructures. The algorithm proposed by the paper\cite{tl} uses \textit{commit-time locking}, which, according to the authors fits well into the memory model of languages like \texttt{C} and \texttt{C++}\cite{tl}. Moreover, as their results suggest, the approach taken by the \textit{TL} algorithm scales better on contention ranges and even when \textit{encounter-order locking} does perform better, it is small enough to be insignificant\cite{tl}.\par

The transactional locking algorithm involves two modes: \textit{encounter mode} and \textit{commit mode}. In both modes, all transactional memory locations are associated with a \textit{versioned-write-lock}, which uses a \textit{Compare-and-Swap} operation to acquire it and a \textit{store} operation to release it. A single bit of the lock indicates whether the lock is taken and the rest of the bits are reserved for the \textit{version} of the location, which is incremented on every lock release.\par 

In commit mode, all transactions maintain \textit{read} and \textit{write} sets. A transactional read first checks whether the address it wishes to access appear in the write-set using a \textit{Bloom filter}\footnote{Bloom filters are probabilistic datastructures that permit testing for membership in $\mathcal{O}$(1) time}, and if so, it loads the current value written to that address. If the write-set does not include the address at hand, the associated lock is fetched and its version is saved in the read-set. If the lock is taken, the transaction may either spin or abort\cite{tl}. Transactional stores are performed such that the address and value of the location are saved in the write-set. Periodically, the read-set is validated to ensure consistent states, and upon encountering inconsistent states, the transaction is aborted\cite{tl}. When committing, the locks are acquired for each store location (as given by the \textit{commit-time locking} mechanism). The acquire step is performed with a single \textit{CAS} operation, which acquires the lock and validates the current version of the location\cite{tl}. After this step, all locks associated with read locations are validated. If the versions matched, the transaction is considered to be \textit{committed}. Otherwise, all locks are released and the transaction is aborted\cite{tl}. Finally, all locks are released associated with write locations by incrementing the corresponding version numbers and clearing the lock bits using a store operation\cite{tl}.\par

Encounter mode operates similarly to the algorithm described by Ennals\cite{ennals-stm}. Here, read and write-sets are also maintained, however, locks are acquired for the write locations at the point when they are encountered, after which the address and value of the location are saved in the write-set. For transactional loads, the behaviour depends on the associated lock. If the lock is found to be unlocked or held by the transaction itself, the location is simply read. Otherwise, the transaction spins on the location\cite{tl}. Similarly to \textit{commit mode}, the read-set is periodically validated to avoid observing inconsistent states, in if such inconsistency is found, the transaction is aborted\cite{tl}. When trying to commit, all locks are acquired corresponding to write locations, which involves a \textit{CAS} operation that increments the version number as well. Following, the read-set is revalidated. If an inconsistency is found, the transaction is unrolled and may be retried. Otherwise, the transaction is considered to be \textit{committed}. Finally, all locks associated with write locations are released by incrementing the corresponding version numbers and clearing the lock bits\cite{tl}.\par

\subsection{TL2}
Later in the same year, Shavit et al. proposed a refinement on the \textit{TL} algorithm, titled \textit{Transactional Locking II} or \textit{TL2}. The authors point out that two limitations of earlier STM implementations remain that prevent them from being deployed. Firstly, non-blocking STM implementations require \textit{closed memory systems}%% !!! %%
, and their blocking counterparts either require the same, or need specialized allocators in terms of \texttt{malloc()} and \texttt{free()} implementations\cite{tl2}. Secondly, in order to ensure that transactions only operate on safe data, specialised runtime environments are employed that could contain such irregularities\cite{tl2}.

The algorithm overcomes the potential problems with earlier non-blocking and blocking STM implementations in the following ways. Firstly, it does not require specialised \texttt{malloc()} or \texttt{free()} implementations, as they fit into the memory model of low-level languages by operating on an \textit{open memory system}. This is achieved by using the associated lock of an object which ensures that a freed location cannot be written by a transaction\cite{tl}. Secondly, the algorithm only operates on consistent memory states, which removes the need for specialised runtime environments\cite{tl2}.

The \textit{TL2} algorithm can be described as a variant of the \textit{TL} algorithm of Dice and Shavit\cite{tl} equipped with a global \textit{version-clock}. The algorithm uses \textit{commit-time locking} and a \textit{version-clock} per application, implemented as a counter which is atomically incremented by every store transaction using \textit{Compare-and-Swap}, and is read by every load transaction\cite{tl2}. Much like the \textit{TL} algorithm, each transactional location is associated with a \textit{versioned write-lock}, a spinlock that is acquired by a \textit{CAS} operation and is released by a \textit{store}. A single bit is reserved to indicate whether the lock is taken, whereas the rest is reserved for the objects \textit{version}, which is advanced upon each successful write\cite{tl2}. The algorithm considers two types of transactions: \textit{write transactions} and \textit{low-cost read transactions}\cite{tl2}.

The execution of \textit{write transactions} can be summarised as follows. First, the global version-clock is saved in a thread-local variable, which will later be used to validate the version field of an accessed object. Then, the transaction is executed speculatively while maintaining local read and write-sets. A transactional load, much like the \textit{TL} algorithm\cite{tl}, first checks using a Bloom filter whether the accessed location appears in its write-set, and if so, it loads the last version of the object. A notable difference compared to the TL algorithm is the use of pre and post-validation of the accessed object's lock, which checks whether the versioned lock is free and has not changed. Moreover, the version of the object is compared to the sampled global version-clock. If it is found that the version of the objects is larger than the global version-clock, indicating that the object had been written by another transaction, the transaction is aborted\cite{tl2}. Following, the locks for the addresses in the write-set is acquired. If this succeeds, the global version-clock is advanced using a \textit{Compare-and-Swap} operation and the returned value is saved again in a thread-local variable, otherwise, the transaction is stopped\cite{tl2}. Then, the read-set is revalidated using the same approach described above. This ensures that the locations had not been written by other transactions while the locks of the write-set are acquired and the global version-clock is advanced. Finally, the transaction \textit{commits} and its held locks are released using a \textit{store}\cite{tl2}.

\textit{Read-only transactions} do not validate the read-set and therefore, can be executed efficiently\cite{tl2}. Deciding whether a transaction is read-only can be done at compile-time, or can be checked by first running each transaction as read-only and when detecting a transactional write, unroll and retry as a writing transaction\cite{tl2}. Read transactions' execution contains two steps. First, the global version-clock is sampled and saved in a thread-local variable. Then, the transaction is executed speculatively, while \textit{post-validating} each load by checking whether the accessed version number is less or equal to the sampled clock. If not, the transaction aborts, else it commits\cite{tl2}.